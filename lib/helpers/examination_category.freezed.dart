// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'examination_category.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ExaminationCategory {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() newToSchedule,
    required TResult Function() unknownLastVisit,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NewToScheduleExamination value) newToSchedule,
    required TResult Function(UnknownLastVisitExamination value)
        unknownLastVisit,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExaminationCategoryCopyWith<$Res> {
  factory $ExaminationCategoryCopyWith(
          ExaminationCategory value, $Res Function(ExaminationCategory) then) =
      _$ExaminationCategoryCopyWithImpl<$Res>;
}

/// @nodoc
class _$ExaminationCategoryCopyWithImpl<$Res>
    implements $ExaminationCategoryCopyWith<$Res> {
  _$ExaminationCategoryCopyWithImpl(this._value, this._then);

  final ExaminationCategory _value;
  // ignore: unused_field
  final $Res Function(ExaminationCategory) _then;
}

/// @nodoc
abstract class _$$ScheduledSoonOrOverdueExaminationCopyWith<$Res> {
  factory _$$ScheduledSoonOrOverdueExaminationCopyWith(
          _$ScheduledSoonOrOverdueExamination value,
          $Res Function(_$ScheduledSoonOrOverdueExamination) then) =
      __$$ScheduledSoonOrOverdueExaminationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ScheduledSoonOrOverdueExaminationCopyWithImpl<$Res>
    extends _$ExaminationCategoryCopyWithImpl<$Res>
    implements _$$ScheduledSoonOrOverdueExaminationCopyWith<$Res> {
  __$$ScheduledSoonOrOverdueExaminationCopyWithImpl(
      _$ScheduledSoonOrOverdueExamination _value,
      $Res Function(_$ScheduledSoonOrOverdueExamination) _then)
      : super(_value, (v) => _then(v as _$ScheduledSoonOrOverdueExamination));

  @override
  _$ScheduledSoonOrOverdueExamination get _value =>
      super._value as _$ScheduledSoonOrOverdueExamination;
}

/// @nodoc

class _$ScheduledSoonOrOverdueExamination
    extends ScheduledSoonOrOverdueExamination {
  const _$ScheduledSoonOrOverdueExamination() : super._();

  @override
  String toString() {
    return 'ExaminationCategory.scheduledSoonOrOverdue()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ScheduledSoonOrOverdueExamination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() newToSchedule,
    required TResult Function() unknownLastVisit,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) {
    return scheduledSoonOrOverdue();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) {
    return scheduledSoonOrOverdue?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) {
    if (scheduledSoonOrOverdue != null) {
      return scheduledSoonOrOverdue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NewToScheduleExamination value) newToSchedule,
    required TResult Function(UnknownLastVisitExamination value)
        unknownLastVisit,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) {
    return scheduledSoonOrOverdue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) {
    return scheduledSoonOrOverdue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) {
    if (scheduledSoonOrOverdue != null) {
      return scheduledSoonOrOverdue(this);
    }
    return orElse();
  }
}

abstract class ScheduledSoonOrOverdueExamination extends ExaminationCategory {
  const factory ScheduledSoonOrOverdueExamination() =
      _$ScheduledSoonOrOverdueExamination;
  const ScheduledSoonOrOverdueExamination._() : super._();
}

/// @nodoc
abstract class _$$NewToScheduleExaminationCopyWith<$Res> {
  factory _$$NewToScheduleExaminationCopyWith(_$NewToScheduleExamination value,
          $Res Function(_$NewToScheduleExamination) then) =
      __$$NewToScheduleExaminationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NewToScheduleExaminationCopyWithImpl<$Res>
    extends _$ExaminationCategoryCopyWithImpl<$Res>
    implements _$$NewToScheduleExaminationCopyWith<$Res> {
  __$$NewToScheduleExaminationCopyWithImpl(_$NewToScheduleExamination _value,
      $Res Function(_$NewToScheduleExamination) _then)
      : super(_value, (v) => _then(v as _$NewToScheduleExamination));

  @override
  _$NewToScheduleExamination get _value =>
      super._value as _$NewToScheduleExamination;
}

/// @nodoc

class _$NewToScheduleExamination extends NewToScheduleExamination {
  const _$NewToScheduleExamination() : super._();

  @override
  String toString() {
    return 'ExaminationCategory.newToSchedule()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NewToScheduleExamination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() newToSchedule,
    required TResult Function() unknownLastVisit,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) {
    return newToSchedule();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) {
    return newToSchedule?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) {
    if (newToSchedule != null) {
      return newToSchedule();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NewToScheduleExamination value) newToSchedule,
    required TResult Function(UnknownLastVisitExamination value)
        unknownLastVisit,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) {
    return newToSchedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) {
    return newToSchedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) {
    if (newToSchedule != null) {
      return newToSchedule(this);
    }
    return orElse();
  }
}

abstract class NewToScheduleExamination extends ExaminationCategory {
  const factory NewToScheduleExamination() = _$NewToScheduleExamination;
  const NewToScheduleExamination._() : super._();
}

/// @nodoc
abstract class _$$UnknownLastVisitExaminationCopyWith<$Res> {
  factory _$$UnknownLastVisitExaminationCopyWith(
          _$UnknownLastVisitExamination value,
          $Res Function(_$UnknownLastVisitExamination) then) =
      __$$UnknownLastVisitExaminationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownLastVisitExaminationCopyWithImpl<$Res>
    extends _$ExaminationCategoryCopyWithImpl<$Res>
    implements _$$UnknownLastVisitExaminationCopyWith<$Res> {
  __$$UnknownLastVisitExaminationCopyWithImpl(
      _$UnknownLastVisitExamination _value,
      $Res Function(_$UnknownLastVisitExamination) _then)
      : super(_value, (v) => _then(v as _$UnknownLastVisitExamination));

  @override
  _$UnknownLastVisitExamination get _value =>
      super._value as _$UnknownLastVisitExamination;
}

/// @nodoc

class _$UnknownLastVisitExamination extends UnknownLastVisitExamination {
  const _$UnknownLastVisitExamination() : super._();

  @override
  String toString() {
    return 'ExaminationCategory.unknownLastVisit()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnknownLastVisitExamination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() newToSchedule,
    required TResult Function() unknownLastVisit,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) {
    return unknownLastVisit();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) {
    return unknownLastVisit?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) {
    if (unknownLastVisit != null) {
      return unknownLastVisit();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NewToScheduleExamination value) newToSchedule,
    required TResult Function(UnknownLastVisitExamination value)
        unknownLastVisit,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) {
    return unknownLastVisit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) {
    return unknownLastVisit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) {
    if (unknownLastVisit != null) {
      return unknownLastVisit(this);
    }
    return orElse();
  }
}

abstract class UnknownLastVisitExamination extends ExaminationCategory {
  const factory UnknownLastVisitExamination() = _$UnknownLastVisitExamination;
  const UnknownLastVisitExamination._() : super._();
}

/// @nodoc
abstract class _$$ScheduledExaminationCopyWith<$Res> {
  factory _$$ScheduledExaminationCopyWith(_$ScheduledExamination value,
          $Res Function(_$ScheduledExamination) then) =
      __$$ScheduledExaminationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ScheduledExaminationCopyWithImpl<$Res>
    extends _$ExaminationCategoryCopyWithImpl<$Res>
    implements _$$ScheduledExaminationCopyWith<$Res> {
  __$$ScheduledExaminationCopyWithImpl(_$ScheduledExamination _value,
      $Res Function(_$ScheduledExamination) _then)
      : super(_value, (v) => _then(v as _$ScheduledExamination));

  @override
  _$ScheduledExamination get _value => super._value as _$ScheduledExamination;
}

/// @nodoc

class _$ScheduledExamination extends ScheduledExamination {
  const _$ScheduledExamination() : super._();

  @override
  String toString() {
    return 'ExaminationCategory.scheduled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ScheduledExamination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() newToSchedule,
    required TResult Function() unknownLastVisit,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) {
    return scheduled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) {
    return scheduled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) {
    if (scheduled != null) {
      return scheduled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NewToScheduleExamination value) newToSchedule,
    required TResult Function(UnknownLastVisitExamination value)
        unknownLastVisit,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) {
    return scheduled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) {
    return scheduled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) {
    if (scheduled != null) {
      return scheduled(this);
    }
    return orElse();
  }
}

abstract class ScheduledExamination extends ExaminationCategory {
  const factory ScheduledExamination() = _$ScheduledExamination;
  const ScheduledExamination._() : super._();
}

/// @nodoc
abstract class _$$WaitingExaminationCopyWith<$Res> {
  factory _$$WaitingExaminationCopyWith(_$WaitingExamination value,
          $Res Function(_$WaitingExamination) then) =
      __$$WaitingExaminationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WaitingExaminationCopyWithImpl<$Res>
    extends _$ExaminationCategoryCopyWithImpl<$Res>
    implements _$$WaitingExaminationCopyWith<$Res> {
  __$$WaitingExaminationCopyWithImpl(
      _$WaitingExamination _value, $Res Function(_$WaitingExamination) _then)
      : super(_value, (v) => _then(v as _$WaitingExamination));

  @override
  _$WaitingExamination get _value => super._value as _$WaitingExamination;
}

/// @nodoc

class _$WaitingExamination extends WaitingExamination {
  const _$WaitingExamination() : super._();

  @override
  String toString() {
    return 'ExaminationCategory.waiting()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WaitingExamination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() newToSchedule,
    required TResult Function() unknownLastVisit,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) {
    return waiting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) {
    return waiting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? newToSchedule,
    TResult Function()? unknownLastVisit,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) {
    if (waiting != null) {
      return waiting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NewToScheduleExamination value) newToSchedule,
    required TResult Function(UnknownLastVisitExamination value)
        unknownLastVisit,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) {
    return waiting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) {
    return waiting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NewToScheduleExamination value)? newToSchedule,
    TResult Function(UnknownLastVisitExamination value)? unknownLastVisit,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) {
    if (waiting != null) {
      return waiting(this);
    }
    return orElse();
  }
}

abstract class WaitingExamination extends ExaminationCategory {
  const factory WaitingExamination() = _$WaitingExamination;
  const WaitingExamination._() : super._();
}
