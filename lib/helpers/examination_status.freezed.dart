// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'examination_status.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ExaminationStatusTearOff {
  const _$ExaminationStatusTearOff();

  ScheduledSoonOrOverdueExamination scheduledSoonOrOverdue() {
    return const ScheduledSoonOrOverdueExamination();
  }

  NeverExamination never() {
    return const NeverExamination();
  }

  UnfinishedExamination unfinished() {
    return const UnfinishedExamination();
  }

  ScheduledExamination scheduled() {
    return const ScheduledExamination();
  }

  WaitingExamination waiting() {
    return const WaitingExamination();
  }
}

/// @nodoc
const $ExaminationStatus = _$ExaminationStatusTearOff();

/// @nodoc
mixin _$ExaminationStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() never,
    required TResult Function() unfinished,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NeverExamination value) never,
    required TResult Function(UnfinishedExamination value) unfinished,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExaminationStatusCopyWith<$Res> {
  factory $ExaminationStatusCopyWith(
          ExaminationStatus value, $Res Function(ExaminationStatus) then) =
      _$ExaminationStatusCopyWithImpl<$Res>;
}

/// @nodoc
class _$ExaminationStatusCopyWithImpl<$Res>
    implements $ExaminationStatusCopyWith<$Res> {
  _$ExaminationStatusCopyWithImpl(this._value, this._then);

  final ExaminationStatus _value;
  // ignore: unused_field
  final $Res Function(ExaminationStatus) _then;
}

/// @nodoc
abstract class $ScheduledSoonOrOverdueExaminationCopyWith<$Res> {
  factory $ScheduledSoonOrOverdueExaminationCopyWith(
          ScheduledSoonOrOverdueExamination value,
          $Res Function(ScheduledSoonOrOverdueExamination) then) =
      _$ScheduledSoonOrOverdueExaminationCopyWithImpl<$Res>;
}

/// @nodoc
class _$ScheduledSoonOrOverdueExaminationCopyWithImpl<$Res>
    extends _$ExaminationStatusCopyWithImpl<$Res>
    implements $ScheduledSoonOrOverdueExaminationCopyWith<$Res> {
  _$ScheduledSoonOrOverdueExaminationCopyWithImpl(
      ScheduledSoonOrOverdueExamination _value,
      $Res Function(ScheduledSoonOrOverdueExamination) _then)
      : super(_value, (v) => _then(v as ScheduledSoonOrOverdueExamination));

  @override
  ScheduledSoonOrOverdueExamination get _value =>
      super._value as ScheduledSoonOrOverdueExamination;
}

/// @nodoc

class _$ScheduledSoonOrOverdueExamination
    extends ScheduledSoonOrOverdueExamination {
  const _$ScheduledSoonOrOverdueExamination() : super._();

  @override
  String toString() {
    return 'ExaminationStatus.scheduledSoonOrOverdue()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ScheduledSoonOrOverdueExamination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() never,
    required TResult Function() unfinished,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) {
    return scheduledSoonOrOverdue();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) {
    return scheduledSoonOrOverdue?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) {
    if (scheduledSoonOrOverdue != null) {
      return scheduledSoonOrOverdue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NeverExamination value) never,
    required TResult Function(UnfinishedExamination value) unfinished,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) {
    return scheduledSoonOrOverdue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) {
    return scheduledSoonOrOverdue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) {
    if (scheduledSoonOrOverdue != null) {
      return scheduledSoonOrOverdue(this);
    }
    return orElse();
  }
}

abstract class ScheduledSoonOrOverdueExamination extends ExaminationStatus {
  const factory ScheduledSoonOrOverdueExamination() =
      _$ScheduledSoonOrOverdueExamination;
  const ScheduledSoonOrOverdueExamination._() : super._();
}

/// @nodoc
abstract class $NeverExaminationCopyWith<$Res> {
  factory $NeverExaminationCopyWith(
          NeverExamination value, $Res Function(NeverExamination) then) =
      _$NeverExaminationCopyWithImpl<$Res>;
}

/// @nodoc
class _$NeverExaminationCopyWithImpl<$Res>
    extends _$ExaminationStatusCopyWithImpl<$Res>
    implements $NeverExaminationCopyWith<$Res> {
  _$NeverExaminationCopyWithImpl(
      NeverExamination _value, $Res Function(NeverExamination) _then)
      : super(_value, (v) => _then(v as NeverExamination));

  @override
  NeverExamination get _value => super._value as NeverExamination;
}

/// @nodoc

class _$NeverExamination extends NeverExamination {
  const _$NeverExamination() : super._();

  @override
  String toString() {
    return 'ExaminationStatus.never()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NeverExamination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() never,
    required TResult Function() unfinished,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) {
    return never();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) {
    return never?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) {
    if (never != null) {
      return never();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NeverExamination value) never,
    required TResult Function(UnfinishedExamination value) unfinished,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) {
    return never(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) {
    return never?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) {
    if (never != null) {
      return never(this);
    }
    return orElse();
  }
}

abstract class NeverExamination extends ExaminationStatus {
  const factory NeverExamination() = _$NeverExamination;
  const NeverExamination._() : super._();
}

/// @nodoc
abstract class $UnfinishedExaminationCopyWith<$Res> {
  factory $UnfinishedExaminationCopyWith(UnfinishedExamination value,
          $Res Function(UnfinishedExamination) then) =
      _$UnfinishedExaminationCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnfinishedExaminationCopyWithImpl<$Res>
    extends _$ExaminationStatusCopyWithImpl<$Res>
    implements $UnfinishedExaminationCopyWith<$Res> {
  _$UnfinishedExaminationCopyWithImpl(
      UnfinishedExamination _value, $Res Function(UnfinishedExamination) _then)
      : super(_value, (v) => _then(v as UnfinishedExamination));

  @override
  UnfinishedExamination get _value => super._value as UnfinishedExamination;
}

/// @nodoc

class _$UnfinishedExamination extends UnfinishedExamination {
  const _$UnfinishedExamination() : super._();

  @override
  String toString() {
    return 'ExaminationStatus.unfinished()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UnfinishedExamination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() never,
    required TResult Function() unfinished,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) {
    return unfinished();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) {
    return unfinished?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) {
    if (unfinished != null) {
      return unfinished();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NeverExamination value) never,
    required TResult Function(UnfinishedExamination value) unfinished,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) {
    return unfinished(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) {
    return unfinished?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) {
    if (unfinished != null) {
      return unfinished(this);
    }
    return orElse();
  }
}

abstract class UnfinishedExamination extends ExaminationStatus {
  const factory UnfinishedExamination() = _$UnfinishedExamination;
  const UnfinishedExamination._() : super._();
}

/// @nodoc
abstract class $ScheduledExaminationCopyWith<$Res> {
  factory $ScheduledExaminationCopyWith(ScheduledExamination value,
          $Res Function(ScheduledExamination) then) =
      _$ScheduledExaminationCopyWithImpl<$Res>;
}

/// @nodoc
class _$ScheduledExaminationCopyWithImpl<$Res>
    extends _$ExaminationStatusCopyWithImpl<$Res>
    implements $ScheduledExaminationCopyWith<$Res> {
  _$ScheduledExaminationCopyWithImpl(
      ScheduledExamination _value, $Res Function(ScheduledExamination) _then)
      : super(_value, (v) => _then(v as ScheduledExamination));

  @override
  ScheduledExamination get _value => super._value as ScheduledExamination;
}

/// @nodoc

class _$ScheduledExamination extends ScheduledExamination {
  const _$ScheduledExamination() : super._();

  @override
  String toString() {
    return 'ExaminationStatus.scheduled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ScheduledExamination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() never,
    required TResult Function() unfinished,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) {
    return scheduled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) {
    return scheduled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) {
    if (scheduled != null) {
      return scheduled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NeverExamination value) never,
    required TResult Function(UnfinishedExamination value) unfinished,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) {
    return scheduled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) {
    return scheduled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) {
    if (scheduled != null) {
      return scheduled(this);
    }
    return orElse();
  }
}

abstract class ScheduledExamination extends ExaminationStatus {
  const factory ScheduledExamination() = _$ScheduledExamination;
  const ScheduledExamination._() : super._();
}

/// @nodoc
abstract class $WaitingExaminationCopyWith<$Res> {
  factory $WaitingExaminationCopyWith(
          WaitingExamination value, $Res Function(WaitingExamination) then) =
      _$WaitingExaminationCopyWithImpl<$Res>;
}

/// @nodoc
class _$WaitingExaminationCopyWithImpl<$Res>
    extends _$ExaminationStatusCopyWithImpl<$Res>
    implements $WaitingExaminationCopyWith<$Res> {
  _$WaitingExaminationCopyWithImpl(
      WaitingExamination _value, $Res Function(WaitingExamination) _then)
      : super(_value, (v) => _then(v as WaitingExamination));

  @override
  WaitingExamination get _value => super._value as WaitingExamination;
}

/// @nodoc

class _$WaitingExamination extends WaitingExamination {
  const _$WaitingExamination() : super._();

  @override
  String toString() {
    return 'ExaminationStatus.waiting()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WaitingExamination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() scheduledSoonOrOverdue,
    required TResult Function() never,
    required TResult Function() unfinished,
    required TResult Function() scheduled,
    required TResult Function() waiting,
  }) {
    return waiting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
  }) {
    return waiting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? scheduledSoonOrOverdue,
    TResult Function()? never,
    TResult Function()? unfinished,
    TResult Function()? scheduled,
    TResult Function()? waiting,
    required TResult orElse(),
  }) {
    if (waiting != null) {
      return waiting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScheduledSoonOrOverdueExamination value)
        scheduledSoonOrOverdue,
    required TResult Function(NeverExamination value) never,
    required TResult Function(UnfinishedExamination value) unfinished,
    required TResult Function(ScheduledExamination value) scheduled,
    required TResult Function(WaitingExamination value) waiting,
  }) {
    return waiting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
  }) {
    return waiting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScheduledSoonOrOverdueExamination value)?
        scheduledSoonOrOverdue,
    TResult Function(NeverExamination value)? never,
    TResult Function(UnfinishedExamination value)? unfinished,
    TResult Function(ScheduledExamination value)? scheduled,
    TResult Function(WaitingExamination value)? waiting,
    required TResult orElse(),
  }) {
    if (waiting != null) {
      return waiting(this);
    }
    return orElse();
  }
}

abstract class WaitingExamination extends ExaminationStatus {
  const factory WaitingExamination() = _$WaitingExamination;
  const WaitingExamination._() : super._();
}
